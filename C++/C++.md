### explicit

用于修饰类的**构造函数**，它的作用是**禁止编译器进行隐式的类型转换**，要求程序员必须显式地调用构造函数。

![image-20250729151455026](D:\kaper\笔记\图片\image-20250729151455026.png)

### inline内联函数

内联函数（`inline`）是 C/C++ 中的一种优化机制，用于减少函数调用的开销。它的核心思想是 **在编译时直接将函数体嵌入到调用处**，而不是生成独立的函数调用指令。

**（1）减少函数调用开销**

- **普通函数调用**：涉及 **压栈（push）、跳转（call）、返回（ret）** 等额外指令，消耗 CPU 周期。
- **内联函数**：编译器直接将函数代码插入调用位置，省去了跳转和返回的开销，适用于 **短小且频繁调用的函数**。

**（2）优化性能**

- 适用于 **高频调用的简单函数**（如 `lv_obj_move_foreground`、数学运算、短小的 getter/setter）。
- 避免 **函数调用的寄存器保存/恢复** 操作，提高执行效率。

**（3）增强编译器优化**

- 内联后，编译器可以 **基于调用处的上下文进行更激进的优化**（如常量传播、死代码消除）。

**3. 内联函数的适用场景**

**✅ 适合内联的函数**

- **短小**（通常不超过 10 行）
- **频繁调用**（如 LVGL 的 `lv_obj_move_foreground`）
- **不包含复杂控制流**（如递归、深层循环）

**❌ 不适合内联的函数**

- **函数体较大**（内联会导致代码膨胀）
- **递归函数**（无法内联）
- **虚函数（C++）**（运行时多态，无法静态展开）

**4. 内联函数的底层机制**

**（1）编译器如何处理 `inline`？**

- **`inline` 只是一个建议**，编译器可以决定是否真正内联。
- 如果函数体 **太长或太复杂**，编译器可能 **忽略 `inline` 关键字**，仍然生成普通函数调用。

```C
// lv_obj.h
static inline void lv_obj_move_foreground(lv_obj_t *obj) {
    if (obj == NULL || obj->parent == NULL) return;
    
    // 直接操作链表调整 Z-order
    _lv_ll_move_to_front(&(obj->parent->child_ll), &(obj->sibling_node));
    lv_obj_mark_layout_as_dirty(obj->parent); // 标记需要重绘
}
```

**为什么用 `static inline`？**

1. **高频调用**：UI 渲染时频繁调整控件层级。
2. **短小简单**：仅修改链表指针，适合内联。
3. **避免符号冲突**：`static` 确保函数仅在当前文件可见。