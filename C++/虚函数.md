**虚函数**是在基类中使用`virtual`关键字声明的成员函数，其目的是允许在派生类中重写该函数，从而实现运行时多态（动态绑定）。

### 虚函数 (Virtual Function)

- 在基类中使用 `virtual` 关键字声明的成员函数
- **允许在派生类中重写该函数**
- **实现运行时多态（动态绑定）**

```c++
class Base {
public:
    virtual void show() {
        std::cout << "Base class show\n";
    }
};
```

#### 工作原理

1.**虚函数表(vtable)**：

- 每个包含虚函数的类都有一个虚函数表
- 表中存储该类所有虚函数的地址
- 对象中包含指向vtable的指针(vptr)

2.**动态绑定过程**：

```C++
Animal* animal = new Dog();
animal->makeSound(); // 动态绑定到Dog::makeSound()
```

- 编译器生成代码**通过vptr查找vtable**
- 从**vtable中获取正确的函数地址**
- 调用该地址指向的函数

### 纯虚函数 (Pure Virtual Function)

- 在**基类中声明但没有实现的虚函数**
- 语法：`virtual void func() = 0;`
- 包含纯虚函数的类成为抽象基类

```c++
class AbstractBase {
public:
    virtual void pureVirtual() = 0; // 纯虚函数
};
```

### 抽象基类 (Abstract Base Class)

- 包含至少一个纯虚函数的类
- **不能被实例化（不能创建对象）**
- 为派生类**定义接口规范**

```c++
class Shape { // 抽象基类
public:
    virtual double area() const = 0; // 纯虚函数
    virtual ~Shape() {} // 虚析构函数
};
```

### 虚析构函数

**虚析构函数**是在基类中声明为`virtual`的析构函数

```C++
class Base {
public:
    virtual ~Base() { // 虚析构函数
        // 清理基类资源
    }
};
```

#### 作用

当存在继承关系时，虚析构函数确保：

1. 通过**基类指针删除派生类对象时，会先调用派生类的析构函数**
2. 然后自动调用基类的析构函数
3. **避免资源泄漏和未定义行为**

#### 使用场景

1. **基类设计**：任何可能被继承的类都应该有虚析构函数
2. **多态删除**：通过基类指针删除派生类对象
3. **标准库兼容**：STL容器存储基类指针时

#### 总结

1. **基类必须有虚析构函数** - 如果类可能被继承并通过基类指针删除
2. **派生类应使用override** - 明确表示重写基类虚析构函数
3. **优先使用智能指针** - 自动处理析构问题，减少手动内存管理错误
4. **不要继承无虚析构函数的类** - 特别是标准库中的类

### override

override用于显**式标明派生类中的函数是重写(override)基类的虚函数**

1. 提高代码可读性
2. 让编译器检查函数签名是否确实重写了基类虚函数
3. 防止因签名不匹配导致意外创建新函数

#### 使用场景

1. 重写基类虚函数时都应使用`override`
2. 防止以下常见错误：

```C++
class Base {
public:
    virtual void func(int);
};

class Derived : public Base {
public:
    void func(float); // 本意是重写，但实际是新建函数
};

//使用override之后
class Derived : public Base {
public:
    void func(float) override; // 编译错误：没有匹配的基类虚函数
};
```

### final

final用于：

1. 禁止派生类重写特定虚函数
2. **禁止类被进一步继承**

```C++
//1.禁止重写虚函数
class Base {
public:
    virtual void func() final; // 此函数不能被子类重写
};

class Derived : public Base {
public:
    // void func() override; // 错误：不能重写final函数
};

//2.禁止类被继承
class Base final { // 此类不能被继承
    // ...
};
// class Derived : public Base {}; // 错误：不能继承final类
```

使用场景

1. 性能优化：标记为final的函数可能**更容易被编译器优化**

```C++
class Utility final { // 工具类不需要扩展
    // ...
};
```

1. 设计**不可扩展的类**
2. 设计**不希望被修改的关键函数**

```C++
class SecuritySystem {
public:
    virtual void authenticate() final; // 关键安全方法不可修改
};
```

![image-20250804110156237](D:\kaper\笔记\图片\image-20250804110156237.png)
